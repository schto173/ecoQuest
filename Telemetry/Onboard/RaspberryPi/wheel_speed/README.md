```markdown
# Rust Wheel Speed Sensor (GPIO RPM Counter)

## Description

This Rust application monitors a specified GPIO pin on a Raspberry Pi (or similar board supported by `rppal`) for falling edge signals, typically generated by a wheel rotation sensor (like a Hall effect sensor or reed switch). It calculates the Revolutions Per Minute (RPM) based on the time interval between signals, applies debouncing to filter noise, averages the RPM over recent readings for smoother output, and writes the current RPM, total rotation count, and a timestamp to a JSON file (`/tmp/wheel_speed.json`).

The script is designed to run continuously and handles graceful shutdown via `Ctrl+C` (SIGINT). It uses a separate thread for non-blocking file writes to minimize impact on the timing-sensitive GPIO monitoring loop.

## Features

*   **GPIO Monitoring:** Uses the `rppal` library to monitor a specific GPIO pin for falling edge interrupts.
*   **Debouncing:** Ignores signals occurring too close together to prevent noise from mechanical switches or sensor bounce.
*   **RPM Calculation:** Calculates instantaneous RPM based on the time duration between consecutive valid signals.
*   **RPM Averaging:** Maintains a buffer of recent RPM readings and calculates a moving average for smoother output.
*   **Timeout Detection:** Resets RPM to 0 if no signal is detected within a configurable timeout period.
*   **JSON Output:** Writes the calculated average RPM, total rotation count, timestamp, and running status to a specified file in JSON format.
*   **Non-Blocking File I/O:** Uses a separate thread and a channel (`mpsc`) to handle file writing asynchronously, preventing blocking in the main monitoring loop.
*   **Graceful Shutdown:** Captures `Ctrl+C` (SIGINT) signal to stop monitoring, perform cleanup, and write a final status update.
*   **GPIO Cleanup:** Attempts to unexport the GPIO pin on exit to release resources.

## Hardware Requirements

*   Raspberry Pi (or other Linux board supported by `rppal` with GPIO access).
*   A wheel rotation sensor (e.g., Hall effect sensor, reed switch with magnet) connected to the configured GPIO pin (`GPIO_PIN`) and Ground. Ensure the sensor provides a falling edge signal on each rotation/trigger.
    *   The script uses the internal pull-up resistor (`into_input_pullup()`), assuming the sensor pulls the pin LOW when triggered. Adjust wiring or code if your sensor works differently (e.g., needs an external pull-up/pull-down or provides a rising edge).

## Software Requirements

*   **Rust Toolchain:** Install Rust (including `cargo`) from [rustup.rs](https://rustup.rs/).
*   **Build Dependencies:** You might need `build-essential` or equivalent C development tools on your system for compiling dependencies.
    ```bash
    sudo apt-get update
    sudo apt-get install build-essential # On Debian/Ubuntu based systems
    ```
*   **GPIO Permissions:** The user running the application typically needs permission to access GPIO. This often involves adding the user to the `gpio` group:
    ```bash
    sudo usermod -a -G gpio $USER
    # Log out and log back in for the group change to take effect
    ```
    Alternatively, run the compiled binary using `sudo`.

## Configuration

Constants within the `main.rs` file can be adjusted:

*   `GPIO_PIN`: The BCM pin number connected to the sensor signal (default: `17`).
*   `TIMEOUT_SECS`: If no signal is received for this many seconds, RPM is reset to 0 (default: `2`).
*   `DEBOUNCE_MS`: Minimum time (in milliseconds) between valid signals to filter noise (default: `20`). Adjust based on sensor characteristics.
*   `STATUS_FILE`: Path to the output JSON file (default: `"/tmp/wheel_speed.json"`). Ensure the directory exists and the user has write permissions.
*   `RPM_BUFFER_SIZE`: Number of recent RPM readings to average over (default: `3`). Increase for smoother but slightly delayed output, decrease for faster response.

## Output File Format (`/tmp/wheel_speed.json`)

The script writes a JSON object to the `STATUS_FILE` with the following structure:

```json
{
  "rpm": 123.45,       // Calculated average RPM (float)
  "count": 567,        // Total number of rotations detected since start (integer)
  "timestamp": 1678886405, // Unix timestamp (seconds since epoch) of the last update (integer)
  "running": true      // Boolean indicating if the script is actively monitoring (true) or shutting down (false)
}
```

## Building & Running

1.  **Clone the Repository (if applicable) or Save the Code:** Save the code as `src/main.rs` within a new Cargo project.
    ```bash
    cargo new wheel_sensor_rust
    cd wheel_sensor_rust
    # Place the code in src/main.rs
    ```
2.  **Add Dependencies to `Cargo.toml`:**
    ```toml
    [package]
    name = "wheel_sensor_rust"
    version = "0.1.0"
    edition = "2021"

    [dependencies]
    rppal = "0.17"        # Check for the latest version
    serde_json = "1.0"
    signal-hook = "0.3"
    ```
3.  **Build the Project:**
    ```bash
    cargo build --release
    ```
    The `--release` flag enables optimizations, recommended for performance.
4.  **Run the Executable:**
    *   Ensure you have GPIO permissions (see Software Requirements).
    *   Execute the compiled binary:
        ```bash
        ./target/release/wheel_sensor_rust
        ```
    *   Or run using `sudo` if needed for permissions:
        ```bash
        sudo ./target/release/wheel_sensor_rust
        ```
5.  **Stop the Script:** Press `Ctrl+C`. The script should print a shutdown message, write a final status update with `running: false`, and attempt GPIO cleanup.

## How it Works

1.  **Initialization:** Sets up GPIO using `rppal`, configuring the specified pin as an input with a pull-up resistor. It also sets up a signal handler for `SIGINT` (`Ctrl+C`).
2.  **File Writer Thread:** Spawns a separate thread that listens on a multi-producer, single-consumer (`mpsc`) channel. When JSON data is sent to the channel, this thread writes it to the `STATUS_FILE` non-blockingly.
3.  **Interrupt Polling:** The main loop waits for a falling edge interrupt on the GPIO pin using `pin.poll_interrupt()`. A timeout is included in the poll.
4.  **Timing & RPM Calculation:**
    *   When an interrupt occurs (and is not filtered by the hardware debounce), it records the current time (`now`).
    *   It calculates the duration since the `last_time` an interrupt occurred.
    *   Instantaneous RPM is calculated as `60.0 / duration_seconds`.
    *   This RPM is added to a `VecDeque` (acting as a circular buffer).
    *   The average RPM is calculated from the values in the buffer.
    *   The `last_time` is updated.
5.  **Timeout Handling:** If `poll_interrupt` returns `None` (timeout), and the current RPM is not already 0, it resets the RPM to 0 and clears the averaging buffer.
6.  **Status Update:** After each valid interrupt or timeout reset, a JSON object containing the current average RPM, total count, timestamp, and running status is created and sent via the channel to the file writer thread.
7.  **Shutdown:** When `Ctrl+C` is pressed, the `running` atomic boolean is set to `false`. The main loop exits, a final status update (`running: false`) is sent, and the `cleanup_gpio` function is called.

## Troubleshooting

*   **"Permission denied" or GPIO errors:** Ensure the user has GPIO access rights (member of `gpio` group or run with `sudo`). Check if another process is using the GPIO pin.
*   **No RPM reading / Count doesn't increase:**
    *   Verify sensor wiring: Signal to `GPIO_PIN`, VCC to 3.3V/5V (check sensor spec), GND to Ground.
    *   Check if the sensor is actually triggering (use a multimeter or oscilloscope if possible).
    *   Ensure the correct `GPIO_PIN` is configured.
    *   Check if the internal pull-up is appropriate for your sensor.
*   **RPM seems erratic / Too high:**
    *   Increase `DEBOUNCE_MS` if noise is suspected.
    *   Check sensor mounting and magnet alignment for clean signals.
*   **`/tmp/wheel_speed.json` not created/updated:**
    *   Check file permissions for `/tmp/` or the specified path.
    *   Look for error messages in the script's console output regarding file writing failures.
```